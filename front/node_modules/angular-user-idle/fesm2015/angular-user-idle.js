import { Injectable, Optional, NgZone, NgModule, defineInjectable, inject } from '@angular/core';
import { Subject, merge, fromEvent, from, interval, timer, of } from 'rxjs';
import { bufferTime, distinctUntilChanged, filter, finalize, map, scan, switchMap, take, takeUntil, tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserIdleConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * User's idle service.
 */
class UserIdleService {
    /**
     * @param {?} config
     * @param {?} _ngZone
     */
    constructor(config, _ngZone) {
        this._ngZone = _ngZone;
        this.timerStart$ = new Subject();
        this.timeout$ = new Subject();
        /**
         * Idle value in seconds.
         * Default equals to 10 minutes.
         */
        this.idle = 600;
        /**
         * Timeout value in seconds.
         * Default equals to 5 minutes.
         */
        this.timeout = 300;
        /**
         * Ping value in seconds.
         * * Default equals to 2 minutes.
         */
        this.ping = 120;
        if (config) {
            this.idle = config.idle;
            this.timeout = config.timeout;
            this.ping = config.ping;
        }
    }
    /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    startWatching() {
        if (!this.activityEvents$) {
            this.activityEvents$ = merge(fromEvent(window, 'mousemove'), fromEvent(window, 'resize'), fromEvent(document, 'keydown'));
        }
        this.idle$ = from(this.activityEvents$);
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
        // If any of user events is not active for idle-seconds when start timer.
        this.idleSubscription = this.idle$
            .pipe(bufferTime(500), // Starting point of detecting of user's inactivity
        filter(arr => !arr.length && !this.isIdleDetected && !this.isInactivityTimer), tap(() => (this.isIdleDetected = true)), switchMap(() => this._ngZone.runOutsideAngular(() => interval(1000).pipe(takeUntil(merge(this.activityEvents$, timer(this.idle * 1000).pipe(tap(() => {
            this.isInactivityTimer = true;
            this.timerStart$.next(true);
        })))), finalize(() => (this.isIdleDetected = false))))))
            .subscribe();
        this.setupTimer(this.timeout);
        this.setupPing(this.ping);
    }
    /**
     * @return {?}
     */
    stopWatching() {
        this.stopTimer();
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    stopTimer() {
        this.isInactivityTimer = false;
        this.timerStart$.next(false);
    }
    /**
     * @return {?}
     */
    resetTimer() {
        this.stopTimer();
        this.isTimeout = false;
    }
    /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    onTimerStart() {
        return this.timerStart$.pipe(distinctUntilChanged(), switchMap(start => (start ? this.timer$ : of(null))));
    }
    /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    onTimeout() {
        return this.timeout$.pipe(filter(timeout => !!timeout), tap(() => (this.isTimeout = true)), map(() => true));
    }
    /**
     * @return {?}
     */
    getConfigValue() {
        return {
            idle: this.idle,
            timeout: this.timeout,
            ping: this.ping
        };
    }
    /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    setConfigValues(config) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set config values');
            return;
        }
        if (config.idle) {
            this.idle = config.idle;
        }
        if (config.ping) {
            this.ping = config.ping;
        }
        if (config.timeout) {
            this.timeout = config.timeout;
        }
    }
    /**
     * Set custom activity events
     *
     * @param {?} customEvents Example: merge(
     *   fromEvent(window, 'mousemove'),
     *   fromEvent(window, 'resize'),
     *   fromEvent(document, 'keydown'),
     *   fromEvent(document, 'touchstart'),
     *   fromEvent(document, 'touchend')
     * )
     * @return {?}
     */
    setCustomActivityEvents(customEvents) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set custom activity events');
            return;
        }
        this.activityEvents$ = customEvents;
    }
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @protected
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    setupTimer(timeout) {
        this._ngZone.runOutsideAngular(() => {
            this.timer$ = interval(1000).pipe(take(timeout), map(() => 1), scan((acc, n) => acc + n), tap(count => {
                if (count === timeout) {
                    this.timeout$.next(true);
                }
            }));
        });
    }
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @protected
     * @param {?} ping
     * @return {?}
     */
    setupPing(ping) {
        this.ping$ = interval(ping * 1000).pipe(filter(() => !this.isTimeout));
    }
}
UserIdleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
UserIdleService.ctorParameters = () => [
    { type: UserIdleConfig, decorators: [{ type: Optional }] },
    { type: NgZone }
];
/** @nocollapse */ UserIdleService.ngInjectableDef = defineInjectable({ factory: function UserIdleService_Factory() { return new UserIdleService(inject(UserIdleConfig, 8), inject(NgZone)); }, token: UserIdleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserIdleModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: UserIdleModule,
            providers: [
                { provide: UserIdleConfig, useValue: config }
            ]
        };
    }
}
UserIdleModule.decorators = [
    { type: NgModule, args: [{
                imports: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { UserIdleService, UserIdleConfig, UserIdleModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci11c2VyLWlkbGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcudHMiLCJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLXVzZXItaWRsZS9saWIvYW5ndWxhci11c2VyLWlkbGUubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBVc2VySWRsZUNvbmZpZyB7XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBpZGxlOiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBwaW5nOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlLFxuICBTdWJqZWN0LFxuICBTdWJzY3JpcHRpb24sXG4gIG1lcmdlLFxuICBmcm9tRXZlbnQsXG4gIGZyb20sXG4gIGludGVydmFsLFxuICB0aW1lcixcbiAgb2Zcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBidWZmZXJUaW1lLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgZmlsdGVyLFxuICBmaW5hbGl6ZSxcbiAgbWFwLFxuICBzY2FuLFxuICBzd2l0Y2hNYXAsXG4gIHRha2UsXG4gIHRha2VVbnRpbCxcbiAgdGFwXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFVzZXJJZGxlQ29uZmlnIH0gZnJvbSAnLi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcnO1xuXG4vKipcbiAqIFVzZXIncyBpZGxlIHNlcnZpY2UuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFVzZXJJZGxlU2VydmljZSB7XG4gIHBpbmckOiBPYnNlcnZhYmxlPGFueT47XG5cbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGNhbiBpbnRlcnJ1cHRzIHVzZXIncyBpbmFjdGl2aXR5IHRpbWVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFjdGl2aXR5RXZlbnRzJDogT2JzZXJ2YWJsZTxhbnk+O1xuXG4gIHByb3RlY3RlZCB0aW1lclN0YXJ0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCB0aW1lb3V0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCBpZGxlJDogT2JzZXJ2YWJsZTxhbnk+O1xuICBwcm90ZWN0ZWQgdGltZXIkOiBPYnNlcnZhYmxlPGFueT47XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqIERlZmF1bHQgZXF1YWxzIHRvIDEwIG1pbnV0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgaWRsZSA9IDYwMDtcbiAgLyoqXG4gICAqIFRpbWVvdXQgdmFsdWUgaW4gc2Vjb25kcy5cbiAgICogRGVmYXVsdCBlcXVhbHMgdG8gNSBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHRpbWVvdXQgPSAzMDA7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqICogRGVmYXVsdCBlcXVhbHMgdG8gMiBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHBpbmcgPSAxMjA7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHN0YXR1cy5cbiAgICovXG4gIHByb3RlY3RlZCBpc1RpbWVvdXQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaW1lciBvZiB1c2VyJ3MgaW5hY3Rpdml0eSBpcyBpbiBwcm9ncmVzcy5cbiAgICovXG4gIHByb3RlY3RlZCBpc0luYWN0aXZpdHlUaW1lcjogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIGlzSWRsZURldGVjdGVkOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCBpZGxlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgY29uZmlnOiBVc2VySWRsZUNvbmZpZywgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB0aGlzLmlkbGUgPSBjb25maWcuaWRsZTtcbiAgICAgIHRoaXMudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuICAgICAgdGhpcy5waW5nID0gY29uZmlnLnBpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHdhdGNoaW5nIGZvciB1c2VyIGlkbGUgYW5kIHNldHVwIHRpbWVyIGFuZCBwaW5nLlxuICAgKi9cbiAgc3RhcnRXYXRjaGluZygpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZpdHlFdmVudHMkKSB7XG4gICAgICB0aGlzLmFjdGl2aXR5RXZlbnRzJCA9IG1lcmdlKFxuICAgICAgICBmcm9tRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJyksXG4gICAgICAgIGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKSxcbiAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmlkbGUkID0gZnJvbSh0aGlzLmFjdGl2aXR5RXZlbnRzJCk7XG5cbiAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgdXNlciBldmVudHMgaXMgbm90IGFjdGl2ZSBmb3IgaWRsZS1zZWNvbmRzIHdoZW4gc3RhcnQgdGltZXIuXG4gICAgdGhpcy5pZGxlU3Vic2NyaXB0aW9uID0gdGhpcy5pZGxlJFxuICAgICAgLnBpcGUoXG4gICAgICAgIGJ1ZmZlclRpbWUoNTAwKSwgLy8gU3RhcnRpbmcgcG9pbnQgb2YgZGV0ZWN0aW5nIG9mIHVzZXIncyBpbmFjdGl2aXR5XG4gICAgICAgIGZpbHRlcihcbiAgICAgICAgICBhcnIgPT4gIWFyci5sZW5ndGggJiYgIXRoaXMuaXNJZGxlRGV0ZWN0ZWQgJiYgIXRoaXMuaXNJbmFjdGl2aXR5VGltZXJcbiAgICAgICAgKSxcbiAgICAgICAgdGFwKCgpID0+ICh0aGlzLmlzSWRsZURldGVjdGVkID0gdHJ1ZSkpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT5cbiAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgIGludGVydmFsKDEwMDApLnBpcGUoXG4gICAgICAgICAgICAgIHRha2VVbnRpbChcbiAgICAgICAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMkLFxuICAgICAgICAgICAgICAgICAgdGltZXIodGhpcy5pZGxlICogMTAwMCkucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzSW5hY3Rpdml0eVRpbWVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnQkLm5leHQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBmaW5hbGl6ZSgoKSA9PiAodGhpcy5pc0lkbGVEZXRlY3RlZCA9IGZhbHNlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKTtcblxuICAgIHRoaXMuc2V0dXBUaW1lcih0aGlzLnRpbWVvdXQpO1xuICAgIHRoaXMuc2V0dXBQaW5nKHRoaXMucGluZyk7XG4gIH1cblxuICBzdG9wV2F0Y2hpbmcoKSB7XG4gICAgdGhpcy5zdG9wVGltZXIoKTtcbiAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBzdG9wVGltZXIoKSB7XG4gICAgdGhpcy5pc0luYWN0aXZpdHlUaW1lciA9IGZhbHNlO1xuICAgIHRoaXMudGltZXJTdGFydCQubmV4dChmYWxzZSk7XG4gIH1cblxuICByZXNldFRpbWVyKCkge1xuICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgdGhpcy5pc1RpbWVvdXQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gb2JzZXJ2YWJsZSBmb3IgdGltZXIncyBjb3VudGRvd24gbnVtYmVyIHRoYXQgZW1pdHMgYWZ0ZXIgaWRsZS5cbiAgICovXG4gIG9uVGltZXJTdGFydCgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnRpbWVyU3RhcnQkLnBpcGUoXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgc3dpdGNoTWFwKHN0YXJ0ID0+IChzdGFydCA/IHRoaXMudGltZXIkIDogb2YobnVsbCkpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIG9ic2VydmFibGUgZm9yIHRpbWVvdXQgaXMgZmlyZWQuXG4gICAqL1xuICBvblRpbWVvdXQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMudGltZW91dCQucGlwZShcbiAgICAgIGZpbHRlcih0aW1lb3V0ID0+ICEhdGltZW91dCksXG4gICAgICB0YXAoKCkgPT4gKHRoaXMuaXNUaW1lb3V0ID0gdHJ1ZSkpLFxuICAgICAgbWFwKCgpID0+IHRydWUpXG4gICAgKTtcbiAgfVxuXG4gIGdldENvbmZpZ1ZhbHVlKCk6IFVzZXJJZGxlQ29uZmlnIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWRsZTogdGhpcy5pZGxlLFxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgcGluZzogdGhpcy5waW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgY29uZmlnIHZhbHVlcy5cbiAgICogQHBhcmFtIGNvbmZpZ1xuICAgKi9cbiAgc2V0Q29uZmlnVmFsdWVzKGNvbmZpZzogVXNlcklkbGVDb25maWcpIHtcbiAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uICYmICF0aGlzLmlkbGVTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYWxsIHN0b3BXYXRjaGluZygpIGJlZm9yZSBzZXQgY29uZmlnIHZhbHVlcycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuaWRsZSkge1xuICAgICAgdGhpcy5pZGxlID0gY29uZmlnLmlkbGU7XG4gICAgfVxuICAgIGlmIChjb25maWcucGluZykge1xuICAgICAgdGhpcy5waW5nID0gY29uZmlnLnBpbmc7XG4gICAgfVxuICAgIGlmIChjb25maWcudGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjdXN0b20gYWN0aXZpdHkgZXZlbnRzXG4gICAqXG4gICAqIEBwYXJhbSBjdXN0b21FdmVudHMgRXhhbXBsZTogbWVyZ2UoXG4gICAqICAgZnJvbUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScpLFxuICAgKiAgIGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKSxcbiAgICogICBmcm9tRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJyksXG4gICAqICAgZnJvbUV2ZW50KGRvY3VtZW50LCAndG91Y2hzdGFydCcpLFxuICAgKiAgIGZyb21FdmVudChkb2N1bWVudCwgJ3RvdWNoZW5kJylcbiAgICogKVxuICAgKi9cbiAgc2V0Q3VzdG9tQWN0aXZpdHlFdmVudHMoY3VzdG9tRXZlbnRzOiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uICYmICF0aGlzLmlkbGVTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYWxsIHN0b3BXYXRjaGluZygpIGJlZm9yZSBzZXQgY3VzdG9tIGFjdGl2aXR5IGV2ZW50cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZpdHlFdmVudHMkID0gY3VzdG9tRXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHRpbWVyLlxuICAgKlxuICAgKiBDb3VudHMgZXZlcnkgc2Vjb25kcyBhbmQgcmV0dXJuIG4rMSBhbmQgZmlyZSB0aW1lb3V0IGZvciBsYXN0IGNvdW50LlxuICAgKiBAcGFyYW0gdGltZW91dCBUaW1lb3V0IGluIHNlY29uZHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0dXBUaW1lcih0aW1lb3V0OiBudW1iZXIpIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy50aW1lciQgPSBpbnRlcnZhbCgxMDAwKS5waXBlKFxuICAgICAgICB0YWtlKHRpbWVvdXQpLFxuICAgICAgICBtYXAoKCkgPT4gMSksXG4gICAgICAgIHNjYW4oKGFjYywgbikgPT4gYWNjICsgbiksXG4gICAgICAgIHRhcChjb3VudCA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQkLm5leHQodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBwaW5nLlxuICAgKlxuICAgKiBQaW5ncyBldmVyeSBwaW5nLXNlY29uZHMgb25seSBpZiBpcyBub3QgdGltZW91dC5cbiAgICogQHBhcmFtIHBpbmdcbiAgICovXG4gIHByb3RlY3RlZCBzZXR1cFBpbmcocGluZzogbnVtYmVyKSB7XG4gICAgdGhpcy5waW5nJCA9IGludGVydmFsKHBpbmcgKiAxMDAwKS5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5pc1RpbWVvdXQpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVzZXJJZGxlQ29uZmlnIH0gZnJvbSAnLi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBVc2VySWRsZU1vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KGNvbmZpZzogVXNlcklkbGVDb25maWcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IFVzZXJJZGxlTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBVc2VySWRsZUNvbmZpZywgdXNlVmFsdWU6IGNvbmZpZ31cbiAgICAgIF1cbiAgICB9O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQUFhLGNBQWM7Q0FhMUI7Ozs7OztBQ2JEOzs7QUFnQ0EsTUFBYSxlQUFlOzs7OztJQXVDMUIsWUFBd0IsTUFBc0IsRUFBVSxPQUFlO1FBQWYsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQS9CN0QsZ0JBQVcsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO1FBQ3JDLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDOzs7OztRQU9sQyxTQUFJLEdBQUcsR0FBRyxDQUFDOzs7OztRQUtYLFlBQU8sR0FBRyxHQUFHLENBQUM7Ozs7O1FBS2QsU0FBSSxHQUFHLEdBQUcsQ0FBQztRQWNuQixJQUFJLE1BQU0sRUFBRTtZQUNWLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztZQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7WUFD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